{
  "language": "Solidity",
  "sources": {
    "contracts/Administration.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.16;\r\n\r\nimport \"./HGSBoxOffice.sol\";\r\nimport \"./DateConverter.sol\";\r\nimport \"./ToString.sol\";\r\n\r\nerror Administration__NotOwner();\r\nerror Administration__CallFailed();\r\nerror Administration__NotRecordedBoxOffice();\r\nerror Administration__AlreadyRecordedVehicle();\r\nerror Administration__NotRecordedVehicle();\r\n\r\ncontract Administration {\r\n  using DateConverter for uint64;\r\n\r\n  enum vehicleType {\r\n    car,\r\n    minibus,\r\n    bus\r\n  }\r\n\r\n  struct vehicleStruct {\r\n    uint64 HGSNumber;\r\n    string name;\r\n    string surname;\r\n    vehicleType vehicleClass;\r\n    uint64[] crossingHistories;\r\n  }\r\n\r\n  struct VehicleCrossingTime {\r\n    DateConverter._DateTime date;\r\n    address vehicle;\r\n  }\r\n\r\n  mapping(address => vehicleStruct) private registeredVehicles;\r\n  address[] private registeredVehiclesAddress;\r\n  mapping(address => bool) private vehicleExists;\r\n  uint256 public numberOfVehicle = 0;\r\n\r\n  address private immutable i_owner;\r\n  address private immutable i_priceFeedAddress;\r\n  address[] public hgsBoxOfficesAddress;\r\n  mapping(address => HGSBoxOffice) hgsBoxOffices;\r\n  mapping(address => bool) hgsBoxOfficesExists;\r\n  uint256 public numberOfOffices = 0;\r\n\r\n  mapping(string => VehicleCrossingTime[]) private dailyPass;\r\n\r\n  constructor(address _priceFeedAddress) {\r\n    i_owner = msg.sender;\r\n    i_priceFeedAddress = _priceFeedAddress;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    if (msg.sender != i_owner) revert Administration__NotOwner();\r\n    _;\r\n  }\r\n\r\n  modifier notRecordedBoxOffice() {\r\n    if (!hgsBoxOfficesExists[msg.sender])\r\n      revert Administration__NotRecordedBoxOffice();\r\n    _;\r\n  }\r\n\r\n  modifier notRecordedBoxOffice2(address _hgsBoxOfficeAddress) {\r\n    if (!hgsBoxOfficesExists[_hgsBoxOfficeAddress])\r\n      revert Administration__NotRecordedBoxOffice();\r\n    _;\r\n  }\r\n\r\n  modifier alreadyRecordedVehicle(address _owner) {\r\n    if (vehicleExists[_owner]) revert Administration__AlreadyRecordedVehicle();\r\n    _;\r\n  }\r\n\r\n  modifier notRecordedVehicle(address _sender) {\r\n    if (!vehicleExists[_sender]) revert Administration__NotRecordedVehicle();\r\n    _;\r\n  }\r\n\r\n  function crossing(address sender)\r\n    public\r\n    notRecordedBoxOffice\r\n    notRecordedVehicle(sender)\r\n  {\r\n    VehicleCrossingTime memory vehicleCrossingTime;\r\n    vehicleCrossingTime.date = uint64(block.timestamp).parseTimestamp();\r\n    vehicleCrossingTime.vehicle = sender;\r\n    string memory day = string.concat(\r\n      Strings.toString(vehicleCrossingTime.date.year),\r\n      \".\",\r\n      Strings.toString(vehicleCrossingTime.date.month),\r\n      \".\",\r\n      Strings.toString(vehicleCrossingTime.date.day)\r\n    );\r\n    dailyPass[day].push(vehicleCrossingTime);\r\n    registeredVehicles[sender].crossingHistories.push(uint64(block.timestamp));\r\n  }\r\n\r\n  function addVehicle(\r\n    address _owner,\r\n    uint64 _HGSNumber,\r\n    string memory _name,\r\n    string memory _surname,\r\n    vehicleType _vehicleClass\r\n  ) public onlyOwner alreadyRecordedVehicle(_owner) {\r\n    registeredVehicles[_owner] = vehicleStruct(\r\n      _HGSNumber,\r\n      _name,\r\n      _surname,\r\n      _vehicleClass,\r\n      new uint64[](0)\r\n    );\r\n    registeredVehiclesAddress.push(_owner);\r\n    vehicleExists[_owner] = true;\r\n    numberOfVehicle++;\r\n  }\r\n\r\n  function deleteVehicle(address _owner) public onlyOwner {\r\n    delete registeredVehicles[_owner];\r\n    numberOfVehicle--;\r\n    vehicleExists[_owner] = false;\r\n  }\r\n\r\n  function createOffice(\r\n    uint256 _CAR_FEE_USD,\r\n    uint256 _MINIBUS_FEE_USD,\r\n    uint256 _BUS_FEE_USD\r\n  ) public onlyOwner {\r\n    HGSBoxOffice _hgsBoxOffices = new HGSBoxOffice(\r\n      this,\r\n      i_priceFeedAddress,\r\n      _CAR_FEE_USD,\r\n      _MINIBUS_FEE_USD,\r\n      _BUS_FEE_USD\r\n    );\r\n    hgsBoxOfficesAddress.push(address(_hgsBoxOffices));\r\n    hgsBoxOffices[address(_hgsBoxOffices)] = _hgsBoxOffices;\r\n    hgsBoxOfficesExists[address(_hgsBoxOffices)] = true;\r\n    numberOfOffices++;\r\n  }\r\n\r\n  function setFees(\r\n    address _hgsBoxOfficeAddress,\r\n    uint256 _CAR_FEE_USD,\r\n    uint256 _MINIBUS_FEE_USD,\r\n    uint256 _BUS_FEE_USD\r\n  ) public onlyOwner notRecordedBoxOffice2(_hgsBoxOfficeAddress) {\r\n    hgsBoxOffices[_hgsBoxOfficeAddress].setFees(\r\n      _CAR_FEE_USD,\r\n      _MINIBUS_FEE_USD,\r\n      _BUS_FEE_USD\r\n    );\r\n  }\r\n\r\n  function deleteOffice(address _hgsBoxOfficeAddress)\r\n    public\r\n    onlyOwner\r\n    notRecordedBoxOffice2(_hgsBoxOfficeAddress)\r\n  {\r\n    hgsBoxOffices[_hgsBoxOfficeAddress].withdraw();\r\n    delete hgsBoxOffices[_hgsBoxOfficeAddress];\r\n    hgsBoxOfficesExists[_hgsBoxOfficeAddress] = false;\r\n    numberOfOffices--;\r\n  }\r\n\r\n  function withdraw() public payable onlyOwner {\r\n    address[] memory _hgsBoxOfficesAddress = hgsBoxOfficesAddress;\r\n    for (uint256 i = 0; i < _hgsBoxOfficesAddress.length; i++) {\r\n      if (hgsBoxOfficesExists[_hgsBoxOfficesAddress[i]])\r\n        hgsBoxOffices[_hgsBoxOfficesAddress[i]].withdraw();\r\n    }\r\n    (bool successCall, ) = payable(msg.sender).call{\r\n      value: address(this).balance\r\n    }(\"\");\r\n    if (!successCall) revert Administration__CallFailed();\r\n  }\r\n\r\n  function totalBalanceOfOffices()\r\n    public\r\n    view\r\n    onlyOwner\r\n    returns (uint256 totalBalance)\r\n  {\r\n    address[] memory _hgsBoxOfficesAddress = hgsBoxOfficesAddress;\r\n    uint256 total = 0;\r\n    for (uint256 i = 0; i < _hgsBoxOfficesAddress.length; i++) {\r\n      total += _hgsBoxOfficesAddress[i].balance;\r\n    }\r\n    return total;\r\n  }\r\n\r\n  function getVehicle(address _owner)\r\n    public\r\n    view\r\n    returns (vehicleStruct memory)\r\n  {\r\n    return registeredVehicles[_owner];\r\n  }\r\n\r\n  function getVehicle() public view returns (vehicleStruct memory) {\r\n    return registeredVehicles[msg.sender];\r\n  }\r\n}\r\n"
    },
    "contracts/HGSBoxOffice.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.16;\r\n\r\nimport \"./PriceConverter.sol\";\r\nimport \"./Administration.sol\";\r\n\r\nerror HGSBoxOffice__LessFee();\r\nerror HGSBoxOffice__CallFailed();\r\nerror HGSBoxOffice__NotRecorded();\r\nerror HGSBoxOffice__NotOwner();\r\n\r\ncontract HGSBoxOffice {\r\n  using PriceConverter for uint256;\r\n\r\n  address private immutable i_owner;\r\n\r\n  AggregatorV3Interface private immutable s_priceFeed;\r\n  Administration private immutable admin;\r\n\r\n  uint256 public CAR_FEE_USD;\r\n  uint256 public MINIBUS_FEE_USD;\r\n  uint256 public BUS_FEE_USD;\r\n\r\n  constructor(\r\n    Administration _admin,\r\n    address priceFeedAddress,\r\n    uint256 _CAR_FEE_USD,\r\n    uint256 _MINIBUS_FEE_USD,\r\n    uint256 _BUS_FEE_USD\r\n  ) {\r\n    i_owner = msg.sender;\r\n    s_priceFeed = AggregatorV3Interface(priceFeedAddress);\r\n    admin = _admin;\r\n\r\n    CAR_FEE_USD = _CAR_FEE_USD;\r\n    MINIBUS_FEE_USD = _MINIBUS_FEE_USD;\r\n    BUS_FEE_USD = _BUS_FEE_USD;\r\n  }\r\n\r\n  modifier notRecorded() {\r\n    if (admin.getVehicle(msg.sender).HGSNumber == 0)\r\n      revert HGSBoxOffice__NotRecorded();\r\n    _;\r\n  }\r\n\r\n  modifier lessFee(Administration.vehicleType vehicleClass, uint256 fee) {\r\n    if (\r\n      (vehicleClass == Administration.vehicleType.car && fee < CAR_FEE_USD) ||\r\n      (vehicleClass == Administration.vehicleType.minibus &&\r\n        fee < MINIBUS_FEE_USD) ||\r\n      (vehicleClass == Administration.vehicleType.bus && fee < BUS_FEE_USD)\r\n    ) {\r\n      revert HGSBoxOffice__LessFee();\r\n    }\r\n    _;\r\n  }\r\n\r\n  modifier notOwner() {\r\n    if (msg.sender != i_owner) revert HGSBoxOffice__NotOwner();\r\n    _;\r\n  }\r\n\r\n  function setFees(\r\n    uint256 _CAR_FEE_USD,\r\n    uint256 _MINIBUS_FEE_USD,\r\n    uint256 _BUS_FEE_USD\r\n  ) public notOwner {\r\n    CAR_FEE_USD = _CAR_FEE_USD;\r\n    MINIBUS_FEE_USD = _MINIBUS_FEE_USD;\r\n    BUS_FEE_USD = _BUS_FEE_USD;\r\n  }\r\n\r\n  function crossing()\r\n    public\r\n    payable\r\n    notRecorded\r\n    lessFee(\r\n      admin.getVehicle(msg.sender).vehicleClass,\r\n      msg.value.getConversionRate(s_priceFeed)\r\n    )\r\n  {\r\n    admin.crossing(msg.sender);\r\n  }\r\n\r\n  function withdraw() public payable notOwner {\r\n    (bool successCall, ) = payable(msg.sender).call{\r\n      value: address(this).balance\r\n    }(\"\");\r\n    if (!successCall) revert HGSBoxOffice__CallFailed();\r\n  }\r\n\r\n  receive() external payable {\r\n    crossing();\r\n  }\r\n\r\n  fallback() external payable {\r\n    crossing();\r\n  }\r\n\r\n  function getVehicle()\r\n    public\r\n    view\r\n    returns (Administration.vehicleStruct memory)\r\n  {\r\n    return admin.getVehicle(msg.sender);\r\n  }\r\n}\r\n"
    },
    "contracts/DateConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.16;\r\n\r\nlibrary DateConverter {\r\n  struct _DateTime {\r\n    uint16 year;\r\n    uint8 month;\r\n    uint8 day;\r\n    uint8 hour;\r\n    uint8 minute;\r\n    uint8 second;\r\n    uint8 weekday;\r\n  }\r\n\r\n  uint256 constant DAY_IN_SECONDS = 86400;\r\n  uint256 constant YEAR_IN_SECONDS = 31536000;\r\n  uint256 constant LEAP_YEAR_IN_SECONDS = 31622400;\r\n\r\n  uint256 constant HOUR_IN_SECONDS = 3600;\r\n  uint256 constant MINUTE_IN_SECONDS = 60;\r\n\r\n  uint16 constant ORIGIN_YEAR = 1970;\r\n\r\n  function isLeapYear(uint16 year) public pure returns (bool) {\r\n    if (year % 4 != 0) {\r\n      return false;\r\n    }\r\n    if (year % 100 != 0) {\r\n      return true;\r\n    }\r\n    if (year % 400 != 0) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  function leapYearsBefore(uint256 year) public pure returns (uint256) {\r\n    year -= 1;\r\n    return year / 4 - year / 100 + year / 400;\r\n  }\r\n\r\n  function getDaysInMonth(uint8 month, uint16 year)\r\n    public\r\n    pure\r\n    returns (uint8)\r\n  {\r\n    if (\r\n      month == 1 ||\r\n      month == 3 ||\r\n      month == 5 ||\r\n      month == 7 ||\r\n      month == 8 ||\r\n      month == 10 ||\r\n      month == 12\r\n    ) {\r\n      return 31;\r\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\r\n      return 30;\r\n    } else if (isLeapYear(year)) {\r\n      return 29;\r\n    } else {\r\n      return 28;\r\n    }\r\n  }\r\n\r\n  function parseTimestamp(uint256 timestamp)\r\n    internal\r\n    pure\r\n    returns (_DateTime memory)\r\n  {\r\n    uint256 secondsAccountedFor = 0;\r\n    uint256 buf;\r\n    uint8 i;\r\n    _DateTime memory dt;\r\n\r\n    // Year\r\n    dt.year = getYear(timestamp);\r\n    buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n    secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\r\n    secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\r\n\r\n    // Month\r\n    uint256 secondsInMonth;\r\n    for (i = 1; i <= 12; i++) {\r\n      secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\r\n      if (secondsInMonth + secondsAccountedFor > timestamp) {\r\n        dt.month = i;\r\n        break;\r\n      }\r\n      secondsAccountedFor += secondsInMonth;\r\n    }\r\n\r\n    // Day\r\n    for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\r\n      if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\r\n        dt.day = i;\r\n        break;\r\n      }\r\n      secondsAccountedFor += DAY_IN_SECONDS;\r\n    }\r\n\r\n    // Hour\r\n    dt.hour = getHour(timestamp);\r\n\r\n    // Minute\r\n    dt.minute = getMinute(timestamp);\r\n\r\n    // Second\r\n    dt.second = getSecond(timestamp);\r\n\r\n    // Day of week.\r\n    dt.weekday = getWeekday(timestamp);\r\n\r\n    return dt;\r\n  }\r\n\r\n  function getYear(uint256 timestamp) public pure returns (uint16) {\r\n    uint256 secondsAccountedFor = 0;\r\n    uint16 year;\r\n    uint256 numLeapYears;\r\n\r\n    // Year\r\n    year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\r\n    numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n    secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\r\n    secondsAccountedFor +=\r\n      YEAR_IN_SECONDS *\r\n      (year - ORIGIN_YEAR - numLeapYears);\r\n\r\n    while (secondsAccountedFor > timestamp) {\r\n      if (isLeapYear(uint16(year - 1))) {\r\n        secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\r\n      } else {\r\n        secondsAccountedFor -= YEAR_IN_SECONDS;\r\n      }\r\n      year -= 1;\r\n    }\r\n    return year;\r\n  }\r\n\r\n  function getMonth(uint256 timestamp) public pure returns (uint8) {\r\n    return parseTimestamp(timestamp).month;\r\n  }\r\n\r\n  function getDay(uint256 timestamp) public pure returns (uint8) {\r\n    return parseTimestamp(timestamp).day;\r\n  }\r\n\r\n  function getHour(uint256 timestamp) public pure returns (uint8) {\r\n    return uint8((timestamp / 60 / 60) % 24);\r\n  }\r\n\r\n  function getMinute(uint256 timestamp) public pure returns (uint8) {\r\n    return uint8((timestamp / 60) % 60);\r\n  }\r\n\r\n  function getSecond(uint256 timestamp) public pure returns (uint8) {\r\n    return uint8(timestamp % 60);\r\n  }\r\n\r\n  function getWeekday(uint256 timestamp) public pure returns (uint8) {\r\n    return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\r\n  }\r\n\r\n  function toTimestamp(\r\n    uint16 year,\r\n    uint8 month,\r\n    uint8 day\r\n  ) public pure returns (uint256 timestamp) {\r\n    return toTimestamp(year, month, day, 0, 0, 0);\r\n  }\r\n\r\n  function toTimestamp(\r\n    uint16 year,\r\n    uint8 month,\r\n    uint8 day,\r\n    uint8 hour\r\n  ) public pure returns (uint256 timestamp) {\r\n    return toTimestamp(year, month, day, hour, 0, 0);\r\n  }\r\n\r\n  function toTimestamp(\r\n    uint16 year,\r\n    uint8 month,\r\n    uint8 day,\r\n    uint8 hour,\r\n    uint8 minute\r\n  ) public pure returns (uint256 timestamp) {\r\n    return toTimestamp(year, month, day, hour, minute, 0);\r\n  }\r\n\r\n  function toTimestamp(\r\n    uint16 year,\r\n    uint8 month,\r\n    uint8 day,\r\n    uint8 hour,\r\n    uint8 minute,\r\n    uint8 second\r\n  ) public pure returns (uint256 timestamp) {\r\n    uint16 i;\r\n\r\n    // Year\r\n    for (i = ORIGIN_YEAR; i < year; i++) {\r\n      if (isLeapYear(i)) {\r\n        timestamp += LEAP_YEAR_IN_SECONDS;\r\n      } else {\r\n        timestamp += YEAR_IN_SECONDS;\r\n      }\r\n    }\r\n\r\n    // Month\r\n    uint8[12] memory monthDayCounts;\r\n    monthDayCounts[0] = 31;\r\n    if (isLeapYear(year)) {\r\n      monthDayCounts[1] = 29;\r\n    } else {\r\n      monthDayCounts[1] = 28;\r\n    }\r\n    monthDayCounts[2] = 31;\r\n    monthDayCounts[3] = 30;\r\n    monthDayCounts[4] = 31;\r\n    monthDayCounts[5] = 30;\r\n    monthDayCounts[6] = 31;\r\n    monthDayCounts[7] = 31;\r\n    monthDayCounts[8] = 30;\r\n    monthDayCounts[9] = 31;\r\n    monthDayCounts[10] = 30;\r\n    monthDayCounts[11] = 31;\r\n\r\n    for (i = 1; i < month; i++) {\r\n      timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\r\n    }\r\n\r\n    // Day\r\n    timestamp += DAY_IN_SECONDS * (day - 1);\r\n\r\n    // Hour\r\n    timestamp += HOUR_IN_SECONDS * (hour);\r\n\r\n    // Minute\r\n    timestamp += MINUTE_IN_SECONDS * (minute);\r\n\r\n    // Second\r\n    timestamp += second;\r\n\r\n    return timestamp;\r\n  }\r\n}\r\n"
    },
    "contracts/ToString.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n  bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n  uint8 private constant _ADDRESS_LENGTH = 20;\r\n\r\n  /**\r\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n   */\r\n  function toString(uint256 value) internal pure returns (string memory) {\r\n    // Inspired by OraclizeAPI's implementation - MIT licence\r\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n    if (value == 0) {\r\n      return \"0\";\r\n    }\r\n    uint256 temp = value;\r\n    uint256 digits;\r\n    while (temp != 0) {\r\n      digits++;\r\n      temp /= 10;\r\n    }\r\n    bytes memory buffer = new bytes(digits);\r\n    while (value != 0) {\r\n      digits -= 1;\r\n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n      value /= 10;\r\n    }\r\n    return string(buffer);\r\n  }\r\n\r\n  /**\r\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n   */\r\n  function toHexString(uint256 value) internal pure returns (string memory) {\r\n    if (value == 0) {\r\n      return \"0x00\";\r\n    }\r\n    uint256 temp = value;\r\n    uint256 length = 0;\r\n    while (temp != 0) {\r\n      length++;\r\n      temp >>= 8;\r\n    }\r\n    return toHexString(value, length);\r\n  }\r\n\r\n  /**\r\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n   */\r\n  function toHexString(uint256 value, uint256 length)\r\n    internal\r\n    pure\r\n    returns (string memory)\r\n  {\r\n    bytes memory buffer = new bytes(2 * length + 2);\r\n    buffer[0] = \"0\";\r\n    buffer[1] = \"x\";\r\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n      buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n      value >>= 4;\r\n    }\r\n    require(value == 0, \"Strings: hex length insufficient\");\r\n    return string(buffer);\r\n  }\r\n\r\n  /**\r\n   * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\r\n   */\r\n  function toHexString(address addr) internal pure returns (string memory) {\r\n    return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\r\n  }\r\n}\r\n"
    },
    "contracts/PriceConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.16;\r\n\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\r\n\r\nlibrary PriceConverter {\r\n  function getPrice(AggregatorV3Interface priceFeed)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n  {\r\n    (, int256 price, , , ) = priceFeed.latestRoundData();\r\n    return uint256(price);\r\n  }\r\n\r\n  function getConversionRate(uint256 ethAmount, AggregatorV3Interface priceFeed)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return (ethAmount * getPrice(priceFeed)) / 1e26;\r\n  }\r\n}\r\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}